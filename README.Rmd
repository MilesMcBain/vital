---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# vital  <img src="man/figures/vital-hex.png" align="right" width = 150 />

<!-- badges: start -->
[![R-CMD-check](https://github.com/robjhyndman/vital/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/robjhyndman/vital/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->

The goal of vital is to allow analysis of demographic data using tidy tools.

## Installation

You can install the **stable** version from
[CRAN](https://cran.r-project.org/package=vital):

```r
pak::pak("vital")
```

You can install the **development** version from
[Github](https://github.com/robjhyndman/vital):

``` r
pak::pak("robjhyndman/vital")
```

## Examples

First load the necessary packages.

```{r packages, message=FALSE}
library(vital)
library(tsibble)
library(dplyr)
library(ggplot2)
```

### vital objects

The basic data object is a `vital`, which is time-indexed tibble that contains vital statistics such as births, deaths, population counts, and mortality and fertility rates. 

We will use Norwegian data in the following examples. First, let's remove the "Total" Sex category and collapse the upper ages into a final age group of 100+.

```{r example}
nor <- norway_mortality |>
  filter(Sex != "Total") |>
  collapse_ages(max_age = 100) 
nor
```

This example contains data from `r min(nor$Year)` to `r max(nor$Year)`. It must have a time "index" variable, and optionally other categorical variables known as "key" variables. Each row must have a unique combination of the index and key variables. Some columns are "vital" variables, such as "Age" and "Sex".

We can use functions to see which variables are index, key or vital:

```{r vars}
index_var(nor)
key_vars(nor)
vital_vars(nor)
```

### Plots

There are `autoplot()` functions for plotting `vital` objects. These produce rainbow plots where each line represents data for one year, and the variable is plotted against age.


```{r autoplot, warning = FALSE}
nor |> 
  autoplot(Mortality) + scale_y_log10()
```

We can use standard ggplot functions to modify the plot as desired. For example, here are population pyramids for all years.

```{r pyramid}
nor |> 
  mutate(Population = if_else(Sex == "Female", -Population, Population)) |>
  autoplot(Population) +
  coord_flip() +
  facet_grid( . ~ Sex, scales = "free_x")
```

### Life tables and life expectancy

Lifetables can be produced using the `life_table()` function. It will produce lifetables for each unique combination of the index and key variables other than age.

```{r lifetable}
# Lifetable in 2000
nor |>
  filter(Year == 2000) |>
  life_table()
```

Life expectancy ($e_x$ with $x=0$ by default) is computed using `life_expectancy()`:

```{r e0}
# Life expectancy
nor |>
  life_expectancy() |>
  ggplot(aes(x = Year, y = ex, color = Sex)) +
  geom_line()
```

### Smoothing 

Several smoothing functions are provided: `smooth_spline()`, `smooth_mortality()`, `smooth_fertility()`, and `smooth_loess()`, each smoothing across the age variable for each year.

```{r smoothing}
# Smoothed data
nor |>
  filter(Year == 1967) |>
  smooth_mortality(Mortality) |>
  autoplot(Mortality) +
  geom_line(aes(y = .smooth), col = "blue") +
  ylab("Mortality rate") +
  scale_y_log10()
```

### Lee-Carter models

Lee-Carter models (Lee & Carter, JASA, 1992) are estimated using the `LC()` function which must be called within a `model()` function:

```{r lc}
# Lee-Carter model
lc <- nor |>
  model(lee_carter = LC(log(Mortality)))
lc
```

Models are fitted for all combinations of key variables excluding age. To see the details for a specific model, use the `report()` function.

```{r lc2}
lc |> 
  filter(Sex == "Female") |> 
  report()
```

The results can be plotted.

```{r lc3}
autoplot(lc)
```

The components can be extracted.

```{r}
age_components(lc)
time_components(lc)
```

Forecasts are obtained using the `forecast()` function

```{r lc5}
# Forecasts from Lee-Carter model
lc |>
  forecast(h = 20) 
```

The forecasts are returned as a distribution column (here transformed normal because of the log transformation used in the model). The `.mean` column gives the point forecasts equal to the mean of the distribution column.


### Functional data models

Functional data models (Hyndman & Ullah, CSDA, 2007) can be estimated in a similar way to Lee-Carter models, but with an additional smoothing step, then modelling with `LC` replaced by `FDM`. 

```{r coherent}
# FDM model
fit <- nor |> 
  smooth_mortality(Mortality) |> 
  model(hu = FDM(log(.smooth)))
fc <- fit |>
  forecast(h = 20) 
autoplot(fc) +
  scale_y_log10()
```

### Coherent functional data models

A coherent functional data model (Hyndman, Booth & Yasmeen, Demography, 2013), is obtained by first computing the sex-products and sex-ratios of the smoothed mortality data. Then a functional data model is fitted to the smoothed data, forecasts are obtained, and the product/ratio transformation is reversed. The following code shows the steps.

```{r coherent2}
fit <- nor |> 
  smooth_mortality(Mortality) |> 
  make_pr(.smooth) |>
  model(hby = FDM(log(.smooth), coherent = TRUE))
fc <- fit |>
  forecast(h = 20) |>
  undo_pr(.smooth)
```

Here, `make_pr()` makes the product-ratios, while `undo_pr()` undoes them.

The argument `coherent = TRUE` in `FDM()` ensures that the ARIMA models fitted to the coefficients are stationary when applied to the sex-ratios. 

